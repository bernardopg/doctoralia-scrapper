# ü§ù Contribuindo para o Doctoralia Scraper

Obrigado por considerar contribuir para o projeto! Este guia ajudar√° voc√™ a entender como contribuir de forma efetiva e manter a qualidade do c√≥digo.

## üìã √çndice

- [C√≥digo de Conduta](#c√≥digo-de-conduta)
- [Como Come√ßar](#como-come√ßar)
- [Processo de Desenvolvimento](#processo-de-desenvolvimento)
- [Padr√µes de C√≥digo](#padr√µes-de-c√≥digo)
- [Testes](#testes)
- [Documenta√ß√£o](#documenta√ß√£o)
- [Code Review](#code-review)
- [Debugging](#debugging)
- [Suporte](#suporte)

## üìú C√≥digo de Conduta

Este projeto segue um c√≥digo de conduta profissional. Ao participar, voc√™ concorda em manter um ambiente colaborativo e respeitoso para todos os contribuidores.

### üéØ **Compromissos**

- **Respeito**: Tratar todos com cortesia e respeito
- **Inclusividade**: Valorizar diferentes perspectivas e experi√™ncias
- **Profissionalismo**: Manter comunica√ß√£o profissional
- **Qualidade**: Priorizar c√≥digo de alta qualidade e bem testado

## üöÄ Como Come√ßar

### üìã **Pr√©-requisitos**

Antes de contribuir, certifique-se de ter:

- **Python 3.10+** instalado
- **Git** configurado
- **Google Chrome** para Selenium
- Familiaridade com desenvolvimento Python

### üõ†Ô∏è **Setup Inicial**

```bash
# 1. Fork o reposit√≥rio
# 2. Clone seu fork
git clone https://github.com/SEU_USERNAME/doctoralia-scraper.git
cd doctoralia-scraper

# 3. Configure ambiente de desenvolvimento
make install-dev

# 4. Configure pre-commit hooks
pip install pre-commit
pre-commit install

# 5. Execute testes para verificar setup
make test
```

### üìù **Encontrando Tarefas**

- **Issues**: Verifique [Issues](../../issues) para tarefas abertas
- **Labels**: Use labels para filtrar por tipo de tarefa
  - `good first issue`: Ideal para iniciantes
  - `enhancement`: Melhorias e novas funcionalidades
  - `bug`: Corre√ß√µes de bugs
  - `documentation`: Melhorias na documenta√ß√£o

## üîß Processo de Desenvolvimento

### üìã **Fluxo de Trabalho**

1. **Escolha uma tarefa** no GitHub Issues
2. **Crie uma branch** descritiva
3. **Desenvolva** seguindo os padr√µes
4. **Teste** suas mudan√ßas
5. **Commit** com mensagens convencionais
6. **Push** e crie um Pull Request
7. **Code Review** e ajustes
8. **Merge** ap√≥s aprova√ß√£o

### üåø **Branches**

```bash
# Para features
git checkout -b feature/nome-da-funcionalidade

# Para corre√ß√µes
git checkout -b fix/nome-do-bug

# Para documenta√ß√£o
git checkout -b docs/melhoria-na-documentacao

# Para manuten√ß√£o
git checkout -b chore/atualizacao-dependencias
```

### üìù **Commits**

Use [Conventional Commits](https://www.conventionalcommits.org/):

```bash
# Features
git commit -m "feat: adiciona suporte a m√∫ltiplas plataformas de scraping"

# Fixes
git commit -m "fix: corrige timeout no scraping de p√°ginas grandes"

# Documentation
git commit -m "docs: atualiza guia de instala√ß√£o no README"

# Tests
git commit -m "test: adiciona testes para response generator"

# Maintenance
git commit -m "chore: atualiza depend√™ncias de desenvolvimento"
```

### üîÑ **Pull Requests**

**Template de PR** deve incluir:

- ‚úÖ **Descri√ß√£o clara** do que foi implementado
- ‚úÖ **Motiva√ß√£o** para as mudan√ßas
- ‚úÖ **Como testar** as altera√ß√µes
- ‚úÖ **Screenshots** se aplic√°vel
- ‚úÖ **Checklist** completo

**Exemplo de PR bem escrito:**

```markdown
## üìã Descri√ß√£o
Adiciona suporte a an√°lise de sentimento usando NLTK VADER para melhorar a qualidade das respostas autom√°ticas.

## üéØ Problema Resolvido
As respostas autom√°ticas n√£o consideravam o sentimento da avalia√ß√£o original, resultando em respostas gen√©ricas.

## ‚úÖ Como Testar
1. Execute `make test` para verificar testes existentes
2. Teste manual: `python -c "from src.response_quality_analyzer import ResponseQualityAnalyzer; print('OK')"`
3. Verifique an√°lise: `make analyze`

## üì∏ Screenshots
[Adicionar screenshots da interface ou resultados]

## ‚òëÔ∏è Checklist
- [x] Testes passando
- [x] Documenta√ß√£o atualizada
- [x] Linting aprovado
- [x] Funcionalidade testada manualmente
```

## üìù Padr√µes de C√≥digo

### üéØ **Princ√≠pios Gerais**

- **Legibilidade**: C√≥digo deve ser claro e autoexplicativo
- **Consist√™ncia**: Seguir padr√µes estabelecidos no projeto
- **Simplicidade**: Solu√ß√µes simples s√£o preferidas
- **Testabilidade**: C√≥digo deve ser facilmente test√°vel
- **Manutenibilidade**: Facilitar futuras modifica√ß√µes

### üêç **Python Style Guide**

#### **PEP 8 Compliance**

```python
# ‚úÖ Correto
def calculate_quality_score(response_text, original_review):
    """Calcula pontua√ß√£o de qualidade da resposta."""
    if not response_text or not original_review:
        return 0.0

    # Implementa√ß√£o
    score = analyze_sentiment(response_text)
    return round(score, 2)

# ‚ùå Incorreto
def calcQualScr(resp,orig): # Sem docstring, nomes ruins
    if not resp or not orig: return 0
    scr=analizeSentiment(resp) # Erro de digita√ß√£o
    return scr
```

#### **Type Hints Obrigat√≥rios**

```python
# ‚úÖ Com type hints
from typing import Optional, Dict, List, Any

def process_reviews(reviews: List[Dict[str, Any]],
                   doctor_name: str,
                   max_reviews: Optional[int] = None) -> Dict[str, Any]:
    """Processa lista de avalia√ß√µes m√©dicas."""
    pass

# ‚ùå Sem type hints
def process_reviews(reviews, doctor_name, max_reviews=None):
    pass
```

#### **Docstrings Completas**

```python
def scrape_doctor_page(url: str,
                      wait_time: float = 2.0,
                      headless: bool = True) -> Optional[Dict[str, Any]]:
    """
    Realiza scraping de p√°gina de m√©dico no Doctoralia.

    Args:
        url: URL completa da p√°gina do m√©dico
        wait_time: Tempo de espera entre a√ß√µes (segundos)
        headless: Executar navegador em modo headless

    Returns:
        Dicion√°rio com dados extra√≠dos ou None se falhar

    Raises:
        ScrapingError: Quando ocorre erro no scraping
        RateLimitError: Quando atingido limite de requisi√ß√µes

    Example:
        >>> data = scrape_doctor_page(
        ...     "https://www.doctoralia.com.br/medico",
        ...     wait_time=3.0
        ... )
        >>> print(data['doctor_name'])
        'Dr. Jo√£o Silva'
    """
```

### üèóÔ∏è **Estrutura de C√≥digo**

#### **Organiza√ß√£o de Imports**

```python
# 1. Imports padr√£o da biblioteca
import json
import logging
from pathlib import Path
from typing import Dict, List, Optional

# 2. Imports de terceiros
import requests
from bs4 import BeautifulSoup
from selenium import webdriver

# 3. Imports locais
from .config import settings
from .errors import ScrapingError
from .utils import setup_logger
```

#### **Classes e M√©todos**

```python
class DoctoraliaScraper:
    """Scraper para plataforma Doctoralia."""

    def __init__(self, config: Dict[str, Any], logger: logging.Logger):
        self.config = config
        self.logger = logger
        self.driver = None
        self._setup_driver()

    def __del__(self):
        """Cleanup do webdriver."""
        if self.driver:
            self.driver.quit()

    def scrape_reviews(self, doctor_url: str) -> Dict[str, Any]:
        """M√©todo principal para scraping de avalia√ß√µes."""
        try:
            self.logger.info(f"Iniciando scraping: {doctor_url}")
            return self._perform_scraping(doctor_url)
        except Exception as e:
            self.logger.error(f"Erro no scraping: {e}")
            raise ScrapingError(f"Falha no scraping: {e}") from e
```

### üõ°Ô∏è **Tratamento de Erros**

#### **Hierarquia de Exce√ß√µes**

```python
class ScrapingError(Exception):
    """Erro base para opera√ß√µes de scraping."""
    pass

class RateLimitError(ScrapingError):
    """Erro quando atingido limite de requisi√ß√µes."""
    pass

class PageNotFoundError(ScrapingError):
    """Erro quando p√°gina n√£o √© encontrada."""
    pass

class NetworkError(ScrapingError):
    """Erro de conectividade de rede."""
    pass
```

#### **Padr√µes de Tratamento**

```python
def safe_scraping_operation(url: str) -> Dict[str, Any]:
    """Opera√ß√£o de scraping com tratamento robusto."""
    try:
        # Tentativa principal
        return perform_scraping(url)
    except RateLimitError:
        # Backoff espec√≠fico para rate limit
        time.sleep(60)
        return perform_scraping(url)
    except NetworkError as e:
        # Retry com exponential backoff
        for attempt in range(3):
            try:
                time.sleep(2 ** attempt)
                return perform_scraping(url)
            except NetworkError:
                continue
        raise ScrapingError(f"Falha de rede ap√≥s 3 tentativas: {e}")
    except Exception as e:
        # Log detalhado para debugging
        logger.error(f"Erro inesperado: {e}", exc_info=True)
        raise ScrapingError(f"Erro inesperado: {e}") from e
```

### üìä **Logging**

#### **N√≠veis Apropriados**

```python
logger = logging.getLogger(__name__)

def scrape_with_logging(url: str) -> Dict[str, Any]:
    """Scraping com logging apropriado."""
    logger.info(f"üöÄ Iniciando scraping: {url}")

    try:
        # Opera√ß√£o normal
        data = perform_scraping(url)
        logger.info(f"‚úÖ Scraping conclu√≠do: {len(data.get('reviews', []))} avalia√ß√µes")
        return data

    except RateLimitError as e:
        logger.warning(f"‚ö†Ô∏è Rate limit atingido, tentando novamente: {e}")
        raise

    except Exception as e:
        logger.error(f"‚ùå Erro cr√≠tico no scraping: {e}", exc_info=True)
        raise
```

#### **Logs Estruturados**

```python
# Para produ√ß√£o, use logs estruturados
logger.info("Scraping completed", extra={
    "url": doctor_url,
    "reviews_count": len(reviews),
    "duration_ms": duration,
    "status": "success"
})
```

    def __init__(self, param1: str, param2: Optional[int] = None):
        self.param1 = param1
        self.param2 = param2

    def example_method(self) -> Dict[str, Any]:
        """
        M√©todo de exemplo

        Returns:
            Dicion√°rio com resultado
        """
        logger.info(f"Executando m√©todo com {self.param1}")
        return {"status": "success"}

```

## üß™ Testes

### Executando Testes

```bash
# Todos os testes
python -m pytest

# Testes espec√≠ficos
python -m pytest tests/test_scraper.py

# Com coverage
python -m pytest --cov=src
```

### Escrevendo Testes

- Use pytest
- Testes unit√°rios em `tests/unit/`
- Testes de integra√ß√£o em `tests/integration/`
- Mocks para depend√™ncias externas

Exemplo:

```python
import pytest
from unittest.mock import Mock, patch
from src.scraper import DoctoraliaScraper


class TestDoctoraliaScraper:

    def test_scraper_initialization(self):
        """Testa inicializa√ß√£o do scraper"""
        config = Mock()
        logger = Mock()
        scraper = DoctoraliaScraper(config, logger)
        assert scraper.config == config

    @patch('src.scraper.webdriver.Chrome')
    def test_scraper_start(self, mock_webdriver):
        """Testa in√≠cio do scraper"""
        # Setup
        config = Mock()
        logger = Mock()
        scraper = DoctoraliaScraper(config, logger)

        # Execute
        scraper.start()

        # Assert
        mock_webdriver.assert_called_once()
```

## üìö Documenta√ß√£o

### Atualizando README

- Mantenha instru√ß√µes atualizadas
- Inclua exemplos de uso
- Documente novas funcionalidades

### Docstrings

Use formato Google:

```python
def complex_function(param1: str, param2: int = 10) -> Dict[str, Any]:
    """
    Fun√ß√£o complexa que faz algo importante.

    Esta fun√ß√£o realiza opera√ß√µes complexas com os par√¢metros
    fornecidos e retorna um resultado estruturado.

    Args:
        param1: String de entrada para processamento
        param2: N√∫mero inteiro para configura√ß√£o (padr√£o: 10)

    Returns:
        Dicion√°rio contendo:
            - status: Status da opera√ß√£o
            - result: Resultado do processamento
            - metadata: Informa√ß√µes adicionais

    Raises:
        ValueError: Quando param1 est√° vazio
        RuntimeError: Quando processamento falha

    Example:
        >>> result = complex_function("test", 20)
        >>> print(result["status"])
        success
    """
```

## üîç Code Review

### Checklist para PRs

- [ ] C√≥digo segue padr√µes estabelecidos
- [ ] Testes passando
- [ ] Documenta√ß√£o atualizada
- [ ] Sem c√≥digo commented out
- [ ] Sem prints de debug
- [ ] Logs apropriados
- [ ] Tratamento de erros
- [ ] Performance considerada

### O que Revisar

1. **Funcionalidade**: O c√≥digo faz o que deveria?
2. **Legibilidade**: C√≥digo √© claro e bem documentado?
3. **Performance**: H√° otimiza√ß√µes √≥bvias?
4. **Seguran√ßa**: N√£o exp√µe dados sens√≠veis?
5. **Manutenibilidade**: C√≥digo √© f√°cil de manter?

## üêõ Debugging

### Logs de Debug

```python
# Use logging em vez de print
logger.debug("Informa√ß√£o de debug")
logger.info("Opera√ß√£o realizada")
logger.warning("Algo suspeito")
logger.error("Erro n√£o cr√≠tico")
logger.critical("Erro cr√≠tico")
```

### Tools √öteis

- `scripts/system_diagnostic.py`: Diagn√≥stico completo
- `scripts/monitor_scraping.py`: Monitor em tempo real
- Logs em `data/logs/`: An√°lise detalhada

## üìû Suporte

- **Issues**: Para bugs e features
- **Discussions**: Para d√∫vidas gerais
- **Email**: Para quest√µes privadas

Obrigado por contribuir! üöÄ
